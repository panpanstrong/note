
一.关键字：
    final:
        1.变量：
            一旦一个变量被声明为final，那么它就不能被重新赋值。final变量通常用于表示常量，它们的值在程序运行期间是不变的。
        2.方法：
            如果一个方法被声明为final，那么它不能被子类重写。也就是说，只有这个方法的原始实现可以被执行，任何尝试重写该方法的子类都会引发编译错误。
        3.类：
            如果一个类被声明为final，那么它不能被继承。也就是说，没有其他类可以继承这个final类。

    static:
        1.静态变量：
            静态变量是类中所有对象共享的变量。这意味着无论你创建多少个类的对象，静态变量都只有一个副本。它不依赖于任何对象实例，因此可以直接通过类名访问，而不需要创建对象。
        2.静态方法：
            静态方法可以直接通过类名调用，无需创建对象。由于静态方法不依赖于任何对象实例，因此它不能直接访问实例变量或方法（除非这些变量或方法是静态的）。
        3.静态代码块：
            静态代码块在类加载时执行，并且只执行一次。静态代码块常用于改变静态变量的初始值。
        4.静态内部类：
            静态内部类不能与外部类的实例共享状态，即静态内部类的成员变量和方法不能直接访问外部类的非静态成员。

    volatile          #确保多线程环境下的变量可见性和顺序性
        1.可见性：
            当一个线程修改了一个volatile变量的值，其他线程会立即看到这个变化。这是因为volatile关键字会禁止CPU缓存和编译器优化，从而确保每次读取变量时都会直接从主内存中获取最新值，
            而不是从本地缓存中读取
        2.顺序性：
            volatile关键字还能确保指令的执行顺序不被重排。
        注：不能保证原子性。也就是说，volatile无法保证复合操作（例如自增或自减等）在多线程环境下的安全性。在这种情况下，需要使用其他同步机制（如synchronized关键字或
            java.util.concurrent.atomic包中的原子类）来确保数据安全

    protected         #定义了类的成员的访问权限,使用protected修饰符的类成员可以被其本身、相同包中的类以及其子类访问。

    abstract          #定义抽象类或者抽象方法
        1.抽象类：
            抽象类是一种不能被实例化的类，他用作其他类的基类，可以包含抽象方法和非抽象方法。如果一个类继承于一个抽象类，那么他必须实现所有的抽象方法。如果一个类继承于一个包含抽象方法
            的类（该类并不是抽象类），那么可以选择是否实现该抽象方法，如果一个类没有实现父类的所有抽象方法，那么它只能是一个抽象类
        2.抽象方法：
            抽象方法是一种只有声明没有实现的方法，并在继承的子类中实现

    synchronized      #互斥锁，确保同一时刻只有一个线程可以访问被synchronized关键字修饰的代码块或者方法。
        1.修饰方法：
            同步方法。一次只能有一个线程访问同步方法，其他试图访问这个方法的线程将会被阻塞，直到当前线程完成这个方法。public synchronized void synchronizedMethod() {}
        2.修饰代码块：
            被synchronized修饰的代码块称为同步块。一次只能有一个线程访问同步块，其他试图访问这个同步块的线程将会被阻塞。
        注：虽然synchronized关键字可以确保线程安全，但是过度使用可能会导致线程阻塞，影响程序性能。同时，还需要注意死锁问题，即多个线程相互等待对方释放资源的情况。

    transient     #用于在对象序列化时标识字段，这些字段不需要或不应被序列化。当一个对象被序列化时，所有的字段都会被存储，除非它们被标记为transient。
        注：使用transient关键字可以确保在序列化过程中不会丢失某些字段的值，因为这些字段可能包含不适合序列化的信息（例如，数据库连接信息，或者在对象反序列化过程中需要重新计算的信息）。

二，数据结构：
        1.ConcurrentHashMap:  #进行迭代操作（如keySet()或values()）时，仍然需要获取全局锁，这可能会降低并发性能
            Java 并发包（java.util.concurrent）中的一个类，它实现了 Map 接口，并提供了线程安全的实现。使用了一种称为分段锁的技术，允许多个修改操作并行进行，而不会相互阻塞。在
            ConcurrentHashMap 中，数据被分成多个段（Segment），每个段都有自己的锁。当线程对某个段进行修改时，只需要对这个段进行加锁，而不是对整个 ConcurrentHashMap。这意味着，
            如果多个线程修改的是不同的段，它们可以同时进行修改，而不会相互阻塞。
            使用场景：
                高并发读写场景：多个线程可以同时访问不同的段，从而提高了并发读写能力
                缓存系统：ConcurrentHashMap支持高并发读取，并且不需要加锁就可以进行读取操作，因此非常适合作为缓存系统中数据结构的选择。
